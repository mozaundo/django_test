import functools
import os
import pkgutil
import sys
from argparse import (
    _AppendConstAction,
    _CountAction,
    _StoreConstAction,
    _SubParsersAction,
)
from collections import defaultdict
from difflib import get_close_matches
from importlib import import_module

import django
from django.apps import apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.management.base import (
    BaseCommand,
    CommandError,
    CommandParser,
    handle_default_options,
)
from django.core.management.color import color_style
from django.utils import autoreload


def find_commands(management_dir):
    """
    Given a path to a management directory, return a list of all the command
    names that are available.
    """
    command_dir = os.path.join(management_dir, "commands")
    return [
        name
        for _, name, is_pkg in pkgutil.iter_modules([command_dir])
        if not is_pkg and not name.startswith("_")
    ]


def load_command_class(app_name, name):
    """
    Given a command name and an application name, return the Command
    class instance. Allow all errors raised by the import process
    (ImportError, AttributeError) to propagate.
    """
    module = import_module("%s.management.commands.%s" % (app_name, name))
    return module.Command()


@functools.lru_cache(maxsize=None)
def get_commands():
    """
    Return a dictionary mapping command names to their callback applications.

    Look for a management.commands package in django.core, and in each
    installed application -- if a commands package exists, register all
    commands in that package.

    Core commands are always included. If a settings module has been
    specified, also include user-defined commands.

    The dictionary is in the format {command_name: app_name}. Key-value
    pairs from this dictionary can then be used in calls to
    load_command_class(app_name, command_name)

    If a specific version of a command must be loaded (e.g., with the
    startapp command), the instantiated module can be placed in the
    dictionary in place of the application name.

    The dictionary is cached on the first call and reused on subsequent
    calls.
    """
    commands = {name: "django.core" for name in find_commands(__path__[0])}

    if not settings.configured:
        return commands

    for app_config in reversed(apps.get_app_configs()):
        path = os.path.join(app_config.path, "management")
        commands.update({name: app_config.name for name in find_commands(path)})

    return commands


def call_command(command_name, *args, **options):
    """
    Call the given command, with the given options and args/kwargs.

    This is the primary API you should use for calling specific commands.

    `command_name` may be a string or a command object. Using a string is
    preferred unless the command object is required for further processing or
    testing.

    Some examples:
        call_command('migrate')
        call_command('shell', plain=True)
        call_command('sqlmigrate', 'myapp')

        from django.core.management.commands import flush
        cmd = flush.Command()
        call_command(cmd, verbosity=0, interactive=False)
        # Do something with cmd ...
    """
    if isinstance(command_name, BaseCommand):
        # Command object passed in.
        command = command_name
        command_name = command.__class__.__module__.split(".")[-1]
    else:
        # Load the command object by name.
        try:
            app_name = get_commands()[command_name]
        except KeyError:
            raise CommandError("Unknown command: %r" % command_name)

        if isinstance(app_name, BaseCommand):
            # If the command is already loaded, use it directly.
            command = app_name
        else:
            command = load_command_class(app_name, command_name)

    # Simulate argument parsing to get the option defaults (see #10080 for details).
    parser = command.create_parser("", command_name)
    # Use the `dest` option name from the parser option
    opt_mapping = {
        min(s_opt.option_strings).lstrip("-").replace("-", "_"): s_opt.dest
        for s_opt in parser._actions
        if s_opt.option_strings
    }
    arg_options = {opt_mapping.get(key, key): value for key, value in options.items()}
    parse_args = []
    for arg in args:
        if isinstance(arg, (list, tuple)):
            parse_args += map(str, arg)
        else:
            parse_args.append(str(arg))

    def get_actions(parser):
        # Parser actions and actions from sub-parser choices.
        for opt in parser._actions:
            if isinstance(opt, _SubParsersAction):
                for sub_opt in opt.choices.values():
                    yield from get_actions(sub_opt)
            else:
                yield opt

    parser_actions = list(get_actions(parser))
    mutually_exclusive_required_options = {
        opt
        for group in parser._mutually_exclusive_groups
        for opt in group._group_actions
        if group.required
    }
    # Any required arguments which are passed in via **options must be passed
    # to parse_args().
    for opt in parser_actions:
        if opt.dest in options and (
            opt.required or opt in mutually_exclusive_required_options
        ):
            opt_dest_count = sum(v == opt.dest for v in opt_mapping.values())
            if opt_dest_count > 1:
                raise TypeError(
                    f"Cannot pass the dest {opt.dest!r} that matches multiple "
                    f"arguments via **options."
                )
            parse_args.append(min(opt.option_strings))
            if isinstance(opt, (_AppendConstAction, _CountAction, _StoreConstAction)):
                continue
            value = arg_options[opt.dest]
            if isinstance(value, (list, tuple)):
                parse_args += map(str, value)
            else:
                parse_args.append(str(value))
    defaults = parser.parse_args(args=parse_args)
    defaults = dict(defaults._get_kwargs(), **arg_options)
    # Raise an error if any unknown options were passed.
    stealth_options = set(command.base_stealth_options + command.stealth_options)
    dest_parameters = {action.dest for action in parser_actions}
    valid_options = (dest_parameters | stealth_options).union(opt_mapping)
    unknown_options = set(options) - valid_options
    if unknown_options:
        raise TypeError(
            "Unknown option(s) for %s command: %s. "
            "Valid options are: %s."
            % (
                command_name,
                ", ".join(sorted(unknown_options)),
                ", ".join(sorted(valid_options)),
            )
        )
    # Move positional args out of options to mimic legacy optparse
    args = defaults.pop("args", ())
    if "skip_checks" not in options:
        defaults["skip_checks"] = True

    return command.execute(*args, **defaults)


class ManagementUtility:
    """
    Encapsulate the logic of the django-admin and manage.py utilities.
    """

    def __init__(self, argv=None):
        self.argv = argv or sys.argv[:]
        self.prog_name = os.path.basename(self.argv[0])
        if self.prog_name == "__main__.py":
            self.prog_name = "python -m django"
        self.settings_exception = None

    def main_help_text(self, commands_only=False):
        """Return the script's main help text, as a string."""
        if commands_only:
            usage = sorted(get_commands())
        else:
            usage = [
                "",
                "Type '%s help <subcommand>' for help on a specific subcommand."
                % self.prog_name,
                "",
                "Available subcommands:",
            ]
            commands_dict = defaultdict(lambda: [])
            for name, app in get_commands().items():
                if app == "django.core":
                    app = "django"
                else:
                    app = app.rpartition(".")[-1]
                commands_dict[app].append(name)
            style = color_style()
            for app in sorted(commands_dict):
                usage.append("")
                usage.append(style.NOTICE("[%s]" % app))
                for name in sorted(commands_dict[app]):
                    usage.append("    %s" % name)
            # Output an extra note if settings are not properly configured
            if self.settings_exception is not None:
                usage.append(
                    style.NOTICE(
                        "Note that only Django core commands are listed "
                        "as settings are not properly configured (error: %s)."
                        % self.settings_exception
                    )
                )

        return "\n".join(usage)

    def fetch_command(self, subcommand):
        """
        Try to fetch the given subcommand, printing a message with the
        appropriate command called from the command line (usually
        "django-admin" or "manage.py") if it can't be found.
        """
        # Get commands outside of try block to prevent swallowing exceptions
        commands = get_commands()
        try:
            app_name = commands[subcommand]
        except KeyError:
            if os.environ.get("DJANGO_SETTINGS_MODULE"):
                # If `subcommand` is missing due to misconfigured settings, the
                # following line will retrigger an ImproperlyConfigured exception
                # (get_commands() swallows the original one) so the user is
                # informed about it.
                settings.INSTALLED_APPS
            elif not settings.configured:
                sys.stderr.write("No Django settings specified.\n")
            possible_matches = get_close_matches(subcommand, commands)
            sys.stderr.write("Unknown command: %r" % subcommand)
            if possible_matches:
                sys.stderr.write(". Did you mean %s?" % possible_matches[0])
            sys.stderr.write("\nType '%s help' for usage.\n" % self.prog_name)
            sys.exit(1)
        if isinstance(app_name, BaseCommand):
            # If the command is already loaded, use it directly.
            klass = app_name
        else:
            klass = load_command_class(app_name, subcommand)
        return klass

    def autocomplete(self):
        """
        Output completion suggestions for BASH.

        The output of this function is passed to BASH's `COMREPLY` variable and
        treated as completion suggestions. `COMREPLY` expects a space
        separated string as the result.

        The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used
        to get information about the cli input. Please refer to the BASH
        man-page for more information about this variables.

        Subcommand options are saved as pairs. A pair consists of
        the long option string (e.g. '--exclude') and a boolean
        value indicating if the option requires arguments. When printing to
        stdout, an equal sign is appended to options which require arguments.

        Note: If debugging this function, it is recommended to write the debug
        output in a separate file. Otherwise the debug output will be treated
        and formatted as potential completion suggestions.
        """
        # Don't complete if user hasn't sourced bash_completion file.
        if "DJANGO_AUTO_COMPLETE" not in os.environ:
            return

        cwords = os.environ["COMP_WORDS"].split()[1:]
        cword = int(os.environ["COMP_CWORD"])

        try:
            curr = cwords[cword - 1]
        except IndexError:
            curr = ""

        subcommands = [*get_commands(), "help"]
        options = [("--help", False)]

        # subcommand
        if cword == 1:
            print(" ".join(sorted(filter(lambda x: x.startswith(curr), subcommands))))
        # subcommand options
        # special case: the 'help' subcommand has no options
        elif cwords[0] in subcommands and cwords[0] != "help":
            subcommand_cls = self.fetch_command(cwords[0])
            # special case: add the names of installed apps to options
            if cwords[0] in ("dumpdata", "sqlmigrate", "sqlsequencereset", "test"):
  ²^‚™Sš„¤îÁ×ËÙ9¨Ï4UÑ,h]½,Í‚¿ ¾/ÃÖÅ#:yÌÒß6+•FâÅq–Ù¼ŞïŸ™ŸÂÖ{ÛU…Ş‘òáèÔrÏq¼â$fÅÿC‹PY¹)ËÀQ†m#=ûTiÊ³ôöx*šYàäsNKšHš=ÍÓGil,îewÄd/»y±öĞÈ„·ÔàÛ007’Ò>Ößş´À8’8“kc×ïÁHùO&d˜™sLj°ÙI$>şDqÔ‰-æK\Ë¯Í¦çØÈÅ^,¦YÉ¸¶’´éCyêŒŸQ¨d{mÎ1–NÄ}F°#y±£ÑÚjĞîa.€İ³6ÒÛ+ı=}aEßi2¼’aËÔÆæw›Ú`X™\
˜P8
4Ôx4#Vs™¥Ÿá"};ª€ÊA@ZtKVd]k"{ã…™{	Õ‹ƒ¤ú#ÎÆ´¼€Œ*OsÜ€>›VÎ¨D#_]NV¾™è6•ïõbŞJ¡÷@
ğÁÔ(†W¨aSdåÿÄxĞ¸NjıYøÒ“zØÔ´—½×L(\ÓÓÖñşÄ&uù.õ
tİá¸J$häçƒ­¬jé¼_¾pImñÁ^ŒÉò%ÄBŸ~<×íÒI=HÔ;9lî÷á•›ÖåÑ=^¤×È„Üßnà¯ ·ÁÊ2BœÅG4]s
¸l³ù^×Ú,4™L$Î„"²Ğv`û÷œİU‹E+í»zù|W_uq•ğ\0R5\{~š‘ìÓ'ÈĞÌ,½´ œ&$¶533h—X³­j®üL®WoÎøº€/-®m ¦™6btq,Ô`Z.>àŸ=Š®ŸèÒË‹TÍ©@•ÖÊ´£ùÃÊ¦í=]@1è¡w}Ç³®%^e‘#o€6ùÖºh*şFşãœäøƒo‚§PÌ|ˆNóÛ‚Âk‘ÓÑÍv€·â7 "«Û/î‡M–şÊµä¼&:œÏSĞNÆçtØ%:„½ãi;tş@ˆUÜSŸ¬ºN‰„ímpâ÷v?4WhÃè7¾N×sşŠ·…;×“(Æè®yíû=¶8‘Bß§s¼Y·!÷”]E'±½ó4ª×¡LgV’µ¶èœØTÔz+§5ö×ôoeÿÀwU¥k—ßàm5 ÚùY3ğ˜ó`É	Î~g'|;FMı¹?PÆiÑJB?Ö°X¶g Âš4R‡Tğf.ZW¸¤İÙ°HæM\À$¯Œ41ªgÉ®2÷…ÁÕ> ¸6«K8çãI]çÑÆGêà\}ƒĞå|Óäª)\rˆ§ˆ­ô%ƒ1®N;ØÖ²î|¨–^bÛoğ8Úì¶~c×Ïã*R:Õ>dfÑâ ‚ÿÏ+ïu3zM/?Ù³3»úY`\LÕI3Çš—Ên“Û(g°’YÀc*¨
ÿÒÂÿùÂ'¡[ªó¾¾nót­vÑù¿j¥^'±~6+XÈçxuŞù¹±he÷–Ymõ0VTäºh9aV0)$Mp6¾¥´5rÔ»	…©ÖãN…ÔX+ú‘Ùa¸l¥ã°L¬ĞÈ½.D¥å•üİéß‹¢ø8û…u=s•t§šğ/É´'Âøi%9e	ë/5bh¢ìõvæ~pu5øC|pŒÀ¢Ñ<	àœ}rŞˆx%‘Ó³Ö×nÄw¹‰µ ¦À²e±ß+*=ÄÔ;WÎ†UZ—À™>Ô/ —ñ”¡"`0l +™aòÆ8õjIâe]@×:Êÿ–şİyõªŸÊ=àFßÆHWö0ïë,…äW¬Úã¹ö·Î9;Ò<sÏ„×ú;÷›œ {¶[q®‹\•Üµó?·ºÿŞ­çX²óO—»”™âıV…Y¦º­ßiEs¢v%ıÙ
„™(¿YÏ<¶>Ö3“	œB¹oÏ)›øÎ±ƒûó,góŒn&K‡ı‹ŒgÖ*6-'‰My«¥­»‚pŒ85Hg>ˆÏ(^‰?Ùî.-Pöã0jÙÓ½½ÛÆúeæ‘c
†ñ… tFÓòáE­ı˜n›ÉBÅI~à¸¦ÿŞ¤ş»›a/²ÖníëØuw>»ÉË¥½§ƒ"ÔÏ	w¤Útü8nşé{™ÿÆ-ÆÎGÑ  ”aP¿—V*i]*µí‡f:`ĞltW6×~
öTìó76ÄãwÔà“ç…½ı½Áä]š¨ö±<²&t%*(»;X•$	nú3?é­`¸éj–3îÜ$Eœ¶=èƒí§T{§ÍèŸ÷3 C¾›?/¡i/ÉÇwÚyrİ>ïd%(¦r^?-–¦T™ïWï]ñÂf*ô¼á€›p'b`ù±]8*€¬:’­¯}££¢ø2iÄ˜EÕÉ†æ–Uˆ»Ø^«U,Š0Èë-X1òÜf¥¹ÖvÕÊ<‰îÕˆ{FÛ]´¹[Éíæ‰b$å-úe)©9ëÔÈË¹Hµ‰¤Jze5@R{võôfjÔL¿±iMFÚc™ÆŸ<€:	B7zXA~bsƒ{üò{'ı^`Ÿš#"ÊmÓ¾EÆé•œuC/fFŒv¡›>,ØëğU?/­ØÒvÿ=ÓMk|îpI++(©²j	6_8÷¡Ø­Š<¤Ø¥˜ GåT¡Ô•É*Ö D'ĞãÕ¦ıåEÓ'©"¡ì!‡#Y[wQ–ıgr(sZo{rT0GĞ¤.ËLç¯+Hdé¬¥=’A°k-á¿ê/8ºÃËs]_ˆWMÁ—ãâİtÑclS¦Ò§äß¶DyLÖ­ôpÈMŒc$ÉÚØ™åjÔ["ÚÏ‡S`wµ©ı¸øÖµˆ1íÜ»ÅQììÍë<OÇŞ£~İ½+ÉEÅ½7]Ú
uw®Ö2ğİQ@åoÀ&CŒræ`¸ö;¼½ºIC]¡|rµnéLë”Äù$ŞfŸ¤W€ñğÿ//ßöíàì¬åùfÍ2{û#d*{” â½oñe±=å {‚8«x‡fıì'˜e†Ç¨zŠNªw¯ô@Kwl¤î¥&7R÷
nC¿ObyÈ£Æ×í&!ŞŞe»¨n·zò×´;ıÛ½ü¦İUğ_³Û•†¬Î†W&Wëèx,î¹ —›™—«´µv¤¶Y–¨Ü˜G®!EŞêÕœqê¬Œ»şr\Ã¥übIˆÚ×T<°èşÒİ^¼LÌ·‘ÕüğÕ¨¢oÆ¯Ò¸èc{ä™‡™ÃáìSN%"›ì0ú à9*¯’¶^¢!qæ³—­\:è)İYõÔ¡šÿZb<¯µO”IçàıÑI‰œ@›=•;ğ‰¡“ÄP<!©Dá$nù|‡«l¨
¸8uátlø‚Ö|«îQ–ÿQ…pIİÑíAh]3Óîdİ›¸Ô®îÃ9i×gĞu÷}#~?Y‘£üİÁ))¨ã2Üó’ ‰m®JCBİãˆª·3_<ˆ¤£’/! ÑÆ%êKLïmVÂrZJå~	åéYŒŸŠ€*ÓîÁè%:lgf»óıIñìñpÎ¯àE	9ˆùÜ§~H³pgßµ¼Ö|¸Ì™[K˜ntÛ~
¸,ât»“°Pl3©7E½Á’ëù3wÊÈh.§°»ß"ŸÁÊ)éÿˆG¶«±F>Û¤ş4ºâì7ìşü”î›'.„r&¼Pí´­ìKŠj$zëHF¹ÖŸëf?g÷6%x+;GÁlË~Îîx„V*ŠlîÇ×A›Ae.¸	%N[.!œ0Û³,ø„mÔõ%³ (;‰(9®xŒ3ç°òcû²¹%ŞÑYñ~‡8œ5fl£ùB"/Wì	g€{!¦É§-‰ø pgYÈ’şòQ:Ñ„…,s+–À¸'Rë¦í¿SñwÕ·ÏÛ–DÏ“ĞpÚ¶bèƒ^$7"Î­	à]nZëİó9ÍÊÿ;vä+nD÷·i%¸R“Ó!² ş:Ò§M È8PKo¨ñë)Áµš)—çKÔF[[„ ¯,¿½Hüõƒé/DìÈƒÒ+¬8‚³l¸¶Tì4Xğë’H§~X¤Må39âH5‡[}¾cz@SÌƒ?-(|¸Ê°­4ãïèÄ^yœy:<Ãeş	 ’Üò(t/;ZuÉ¹—û7ûõq÷:vÍã{µ­6p¡Ñ#îÉƒƒ˜Q(;øCìÕµbÉ£31À1ŠHR1	(‚¢©b€otj²ìÎ{°lHWÎĞêÚ©®4Ù(dÃ•tş•eÍØ;/•)c<t/{å…q¶Ì©wC6Š+¡¬Û#Ïåqóåü×?t§¡½W†Vä¡dh†SÀĞ^šš'?òC;z¹$ õ¦¤Æßğà~dçûDiNÿK°cCíb!zœbÓJ=f2Ã™FZ|iŞö‡#xyûÉ¸†r¢cHiõáÔÂ)`û´³Lêr¼„Ïÿİ%äÍµlAëÁëI÷ŠË­óDÍÔå²ª¢[ÀD½£~1dnn0Ïâ[ßFáe‘ 2¯?ìc70‚ÁPìH‚Ã¡C‘wDpóù¾ÈÑ›ø›$^T$íù~Ú‚?[?+ÎVÓúáÆáõŠELÍ¿Fn}bØEn}©ÛpŸÇ¸N‰ğ™B(¶yâüEÓ]#ï%~ğµiÇ]Ğk˜Îît!iw¾ç7B›#Í\F¡ïğ³4æÅŸøY·¤ˆ ‡ëG2JtÀ°UÖ˜÷\“´Aƒ?Ö"Æ‡6†<Z™ôAA<ü‘S\øZ=éµ†À|a­z`jåákJ&°IıT}):¨xæ‡'Õ™C”å‡,cHòAµwµtuô`Oµ-r¢‘@xDá¥MÔ™>ê°½Îİõl7E²'©ÃAú`fa±Úº;s^‡ËoÏä¢h%²ï÷¨™öoÂİ°¬(DCL1cOå
TTœb‹‹õL)o•)¯Bßø~QtšâÀ<_•¸H-[Ó¥Xå›`kgÌ!êïV…¡í³[­Ğ¤~ë$T•¿ r"š‚ìœ:Q$’U±XÉ“–t·`İå6çá¿Œ—Øçç1HÄmc/İ‰Ş“-íZÿÓÖ˜çO!”`ÜÉû"ä›38YÜí€?‚ Å¾¡8ó¹JÀÊöÎvf5ô†Ÿ=3Ô‘‚Éáãf·ÉP²b 
À€ç’{~	l˜.µÕµgÇCsÅ†1•0wmÕœhwjAÄwLLC¯!ÓAk8ãC¯µ–v7ÅjÏs…Î%Š¦èiïq~#èOÊö–Ê2‰ÖÜ•3>	…né¨~—ÙÁ¥Oîÿƒ@]è Ñ×c"‹şo2©!Ä‡÷ÇUá¹…Ë[At pÀô¶ñ~)r–¾&rûÓY™ÀNY¨¥M2†ïKáÖ¿)…_ùf(ß
ög¤Fh.~<È…"˜®)¬²üRI1r1õ/Ä]¨Æ]ğ2A®éÂ<Õêéé×s‰ÖÄã^ˆPôpƒ~r†ş÷õ.s?ê¯CYT^ª5Vy ˜«ºŞÒQñcé(ø£T±¿—·g¼í“PõÀdÕcÓ
Ç–!##ÃL†PŠŒñ÷e»EèèD…ûÑ(#F×²jfıY_‘½œÊuc‹9K¯uÎ¯9çK¹&9i+<¾åè`ÈÍNiÎ?<QEĞã¬('uºIIè±ùú?Z%ÉÑÒÒ–QÀ¬%ÛÊ‡{s˜¿­Jdá‚r<ÂævLQ—Æ/Ã¶<õ]æc‡üºò±Uöîi÷
µÈª
²z3/ÉJéŠé£$ˆ[òa¢ó>ÈGƒ4"çŒPƒ²3İH0eyÉ*Ô…{ä3)ÙG¯FÛlãxÉT™"–"ØÏ9œÛÃ•)_E—³•[Z‰Â):_Ñ°ÏÍkœ¢‘š—z¨#>—P~—IÑ©{#bmÙ£gOK7I„èĞÏŒXI' WØJ«kh“ºÛ3ÕwÀnˆGA…•9ê—µ½²/ü°­u,ĞÇğ‘÷Áµ3«jF˜WyÛºÊ…‡PŞ¾¥´7Åğ
i±‹E4¥Ät™uD—Ô‹çr‘¦±×©ÃÁk¬>êC ûæÄróyÓĞ*Kôa‹>H½ëtëCõÍÅ3ÇÂ÷èn ÅZ°$Úª:Ëp¸ÿù‰CúE«K¾&°‹*Sò°Æ½WÚ´D¹¤Ø{à£İPFK—’dø¹6óé#w¸h¥?«}U*ì0D¬ˆ¯¼©uşœ9}²k×8õš§^•²LCHw±„µUI¨÷T±ƒõ}ƒGöô=q•	r4.Í\Ä(Éä5:Iöıï]Zâcö:ë“R£{êK+Ñ&-
êúÉQÅëyóá™"ÏÑY}V1¦™Æ¶§n¬É¹½ø€d
+ÌAqx„åı‘bôQpµš~
ì%6t"¾9¾™â1eLŞV¾ï|¼£D&–É³Ş>vå¬ˆ®Z±]¡$}öÁÅA±Ô&–ßcÕÎ>§|Ğ^ä€Ì†_K4f<8n*»5%ã(_¼×œ'Ò¿É¿bV³P søşˆÁí¦«,Ç¸ç3y?j¾ıíàªâs$·Œ[öÉqWz÷’Æö\K [å*È(¯'àfœØfã”QyæVPø—á^Æia•2%ù²Vñ¿HãhÚ5ILMPèì5¹D|sÎL¹`ít˜0ÆÜ8ï)Ey£’r8 Ú÷iäš¹WKp^bM;_:×1rÜSÏ£ÎD“«~“£Ó•ÌZœA	&m}A›î•lqÊÀlnÑ`éITäP~}—£„gb¼Cß‚ú]dèø4fåLŸšfÆ :´o«&ã”91Gü’qG;÷#•…P"rF«¨4¨à¨Èi2Óe:‰Í¬½Wd’İ‹oÀ¾•Î·CE{ødèf–7]óŠ;º˜B:óƒš·úŒQ–œ¯´„Ş?pĞßùDL¼Çl7s¯©•®xş "·íÍàÂÌésĞ6.œ£ØH{,eÓbäG´ı{–N