import sys
import time
from importlib import import_module

from django.apps import apps
from django.core.management.base import BaseCommand, CommandError, no_translations
from django.core.management.sql import emit_post_migrate_signal, emit_pre_migrate_signal
from django.db import DEFAULT_DB_ALIAS, connections, router
from django.db.migrations.autodetector import MigrationAutodetector
from django.db.migrations.executor import MigrationExecutor
from django.db.migrations.loader import AmbiguityError
from django.db.migrations.state import ModelState, ProjectState
from django.utils.module_loading import module_has_submodule
from django.utils.text import Truncator


class Command(BaseCommand):
    help = (
        "Updates database schema. Manages both apps with migrations and those without."
    )
    requires_system_checks = []

    def add_arguments(self, parser):
        parser.add_argument(
            "--skip-checks",
            action="store_true",
            help="Skip system checks.",
        )
        parser.add_argument(
            "app_label",
            nargs="?",
            help="App label of an application to synchronize the state.",
        )
        parser.add_argument(
            "migration_name",
            nargs="?",
            help="Database state will be brought to the state after that "
            'migration. Use the name "zero" to unapply all migrations.',
        )
        parser.add_argument(
            "--noinput",
            "--no-input",
            action="store_false",
            dest="interactive",
            help="Tells Django to NOT prompt the user for input of any kind.",
        )
        parser.add_argument(
            "--database",
            default=DEFAULT_DB_ALIAS,
            help=(
                'Nominates a database to synchronize. Defaults to the "default" '
                "database."
            ),
        )
        parser.add_argument(
            "--fake",
            action="store_true",
            help="Mark migrations as run without actually running them.",
        )
        parser.add_argument(
            "--fake-initial",
            action="store_true",
            help=(
                "Detect if tables already exist and fake-apply initial migrations if "
                "so. Make sure that the current database schema matches your initial "
                "migration before using this flag. Django will only check for an "
                "existing table name."
            ),
        )
        parser.add_argument(
            "--plan",
            action="store_true",
            help="Shows a list of the migration actions that will be performed.",
        )
        parser.add_argument(
            "--run-syncdb",
            action="store_true",
            help="Creates tables for apps without migrations.",
        )
        parser.add_argument(
            "--check",
            action="store_true",
            dest="check_unapplied",
            help="Exits with a non-zero status if unapplied migrations exist.",
        )
        parser.add_argument(
            "--prune",
            action="store_true",
            dest="prune",
            help="Delete nonexistent migrations from the django_migrations table.",
        )

    @no_translations
    def handle(self, *args, **options):
        database = options["database"]
        if not options["skip_checks"]:
            self.check(databases=[database])

        self.verbosity = options["verbosity"]
        self.interactive = options["interactive"]

        # Import the 'management' module within each installed app, to register
        # dispatcher events.
        for app_config in apps.get_app_configs():
            if module_has_submodule(app_config.module, "management"):
                import_module(".management", app_config.name)

        # Get the database we're operating from
        connection = connections[database]

        # Hook for backends needing any database preparation
        connection.prepare_database()
        # Work out which apps have migrations and which do not
        executor = MigrationExecutor(connection, self.migration_progress_callback)

        # Raise an error if any migrations are applied before their dependencies.
        executor.loader.check_consistent_history(connection)

        # Before anything else, see if there's conflicting apps and drop out
        # hard if there are any
        conflicts = executor.loader.detect_conflicts()
        if conflicts:
            name_str = "; ".join(
                "%s in %s" % (", ".join(names), app) for app, names in conflicts.items()
            )
            raise CommandError(
                "Conflicting migrations detected; multiple leaf nodes in the "
                "migration graph: (%s).\nTo fix them run "
                "'python manage.py makemigrations --merge'" % name_str
            )

        # If they supplied command line arguments, work out what they mean.
        run_syncdb = options["run_syncdb"]
        target_app_labels_only = True
        if options["app_label"]:
            # Validate app_label.
            app_label = options["app_label"]
            try:
                apps.get_app_config(app_label)
            except LookupError as err:
                raise CommandError(str(err))
            if run_syncdb:
                if app_label in executor.loader.migrated_apps:
                    raise CommandError(
                        "Can't use run_syncdb with app '%s' as it has migrations."
                        % app_label
                    )
            elif app_label not in executor.loader.migrated_apps:
                raise CommandError("App '%s' does not have migrations." % app_label)

        if options["app_label"] and options["migration_name"]:
            migration_name = options["migration_name"]
            if migration_name == "zero":
                targets = [(app_label, None)]
            else:
                try:
                    migration = executor.loader.get_migration_by_prefix(
                        app_label, migration_name
                    )
                except AmbiguityError:
                    raise CommandError(
                        "More than one migration matches '%s' in app '%s'. "
                        "Please be more specific." % (migration_name, app_label)
                    )
                except KeyError:
                    raise CommandError(
                        "Cannot find a migration matching '%s' from app '%s'."
                        % (migration_name, app_label)
                    )
                target = (app_label, migration.name)
                # Partially applied squashed migrations are not included in the
                # graph, use the last replacement instead.
                if (
                    target not in executor.loader.graph.nodes
                    and target in executor.loader.replacements
                ):
                    incomplete_migration = executor.loader.replacements[target]
                    target = incomplete_migration.replaces[-1]
                targets = [target]
            target_app_labels_only = False
        elif options["app_label"]:
            targets = [
                key for key in executor.loader.graph.leaf_nodes() if key[0] == app_label
            ]
        else:
            targets = executor.loader.graph.leaf_nodes()

        if options["prune"]:
            if not options["app_label"]:
                raise CommandError(
                    "Migrations can be pruned only when an app is specified."
                )
            if self.verbosity > 0:
                self.stdout.write("Pruning migrations:", self.style.MIGRATE_HEADING)
            to_prune = set(executor.loader.applied_migrations) - set(
                executor.loader.disk_migrations
            )
            squashed_migrations_with_deleted_replaced_migrations = [
                migration_key
                for migration_key, migration_obj in executor.loader.replacements.items()
                if any(replaced in to_prune for replaced in migration_obj.replaces)
            ]
            if squashed_migrations_with_deleted_replaced_migrations:
                self.stdout.write(
                    self.style.NOTICE(
                        "  Cannot use --prune because the following squashed "
                        "migrations have their 'replaces' attributes and may not "
                        "be recorded as applied:"
                    )
                )
                for migration in squashed_migrations_with_deleted_replaced_migrations:
                    app, name = migration
                    self.stdout.write(f"    {app}.{name}")
                self.stdout.write(
                    self.style.NOTICE(
                        "  Re-run 'manage.py migrate' if they are not marked as "
                        "applied, and remove 'replaces' attributes in their "
                        "Migration classes."
                    )
                )
            else:
                to_prune = sorted(
                    migration for migration in to_prune if migration[0] == app_label
                )
                if to_prune:
                    for migration in to_prune:
                        app, name = migration
                        if self.verbosity > 0:
                            self.stdout.write(
                                self.style.MIGRATE_LABEL(f"  Pruning {app}.{name}"),
                                ending="",
                            )
                        executor.recorder.record_unapplied(app, name)
                        if self.verbosity > 0:
                            self.stdout.write(self.style.SUCCESS(" OK"))
                elif self.verbosity > 0:
                    self.stdout.write("  No migrations to prune.")

        plan = executor.migration_plan(targets)
        exit_dry = plan and options["check_unapplied"]

        if options["plan"]:
            self.stdout.write("Planned operations:", self.style.MIGRATE_LABEL)
            if not plan:
                self.stdout.write("  No planned migration operations.")
            for migration, backwards in plan:
                self.stdout.write(str(migration), self.style.MIGRATE_HEADING)
                for operation in migration.operations:
                    message, is_error = self.describe_operation(operation, backwards)
                    style = self.style.WARNING if is_error else None
                    self.stdout.write("    " + message, style)
            if exit_dry:
                sys.exit(1)
            return
        if exit_dry:
            sys.exit(1)
        if options["prune"]:
            return

        # At this point, ignore run_syncdb if there aren't any apps to sync.
        run_syncdb = options["run_syncdb"] and executor.loader.unmigrated_apps
        # Print some useful info
        if self.verbosity >= 1:
            self.stdout.write(self.style.MIGRATE_HEADING("Operations to perform:"))
            if run_syncdb:
                if options["app_label"]:
                    self.stdout.write(
                        self.style.MIGRATE_LABEL(
                            "  Synchronize unmigrated app: %s" % app_label
                        )
                    )
                else:
                    self.stdout.write(
                        self.style.MIGRATE_LABEL("  Synchronize unmigrated apps: ")
                        + (", ".join(sorted(executor.loader.unmigrated_apps)))
                    )
            if target_app_labels_only:
                self.stdout.write(
                    self.style.MIGRATE_LABEL("  Apply all migrations: ")
                    + (", ".join(sorted({a for a, n in targets})) or "(none)")
                )
            else:
                if targets[0][1] is None:
                    self.stdout.write(
                        self.style.MIGRATE_LABEL("  Unapply all migrations: ")
                        + str(targets[0][0])
                    )
                else:
                    self.stdout.write(
                        self.style.MIGRATE_LABEL("  Target specific migration: ")
                        + "%s, from %s" % (targets[0][1], targets[0][0])
                    )

        pre_migrate_state = executor._create_project_state(with_applied_migrations=True)
        pre_migrate_apps = pre_migrate_state.apps
        emit_pre_migrate_signal(
            self.verbosity,
            self.interactive,
            connection.alias,
            stdout=self.stdout,
            apps=pre_migrate_apps,
            plan=plan,
        )

        # Run the syncdb phase.
        if run_syncdb:
            if self.verbosity >= 1:
                self.stdout.write(
                    self.style.MIGRATE_HEADING("Synchronizing apps without migrations:")
                )
            if options["app_label"]:
                self.sync_apps(connection, [app_label])
            else:
                self.sync_apps(connection, executor.loader.unmigrated_apps)

        # Migrate!
        if self.verbosity >= 1:
            self.stdout.write(self.style.MIGRATE_HEADING("Running migrations:"))
        if not plan:
            if self.verbosity >= 1:
                self.stdout.write("  No migrations to apply.")
                # If there's changes that aren't in migrations yet, tell them
                # how to fix it.
                autodetector = MigrationAutodetector(
                    executor.loader.project_state(),
                    ProjectState.from_apps(apps),
                )
                changes = autodetector.changes(graph=executor.loader.graph)
                if changes:
                    self.stdout.write(
                        self.style.NOTICE(
                            "  Your models in app(s): %s have changes that are not "
                            "yet reflected in a migration, and so won't be "
                            "applied." % ", ".join(repr(app) for app in sorted(changes))
                        )
                    )
                    self.stdout.write(
                        self.style.NOTICE(
                            "  Run 'manage.py makemigrations' to make new "
                            "migrations, and then re-run 'manage.py migrate' to "
                            "apply them."
                        )
                    )
            fake = False
            fake_initial = False
        else:
            fake = options["fake"]
            fake_initial = options["fake_initial"]
        post_migrate_state = executor.migrate(
            targets,
            plan=plan,
            state=pre_migrate_state.clone(),
            fake=fake,
            fake_initial=fake_initial,
        )
        # post_migrate signals have access to all models. Ensure that all models
        # are reloaded in case any are delayed.
        post_migrate_state.clear_delayed_apps_cache()
        post_migrate_apps = post_migrate_state.apps

        # Re-render models of real apps to include relationships now that
        # we've got a final state. This wouldn't be necessary if real apps
        # models were rendered with relationships in the first place.
        with post_migrate_apps.bulk_update():
            model_keys = []
            for model_state in post_migrate_apps.real_models:
                model_key = model_state.app_label, model_state.name_lower
                model_keys.append(model_key)
                post_migrate_apps.unregister_model(*model_key)
        post_migrate_apps.render_multiple(
            [ModelState.from_model(apps.get_model(*model)) for model in model_keys]
        )

        # Send the post_migrate signal, so individual apps can do whatever they need
        # to do at this point.
        emit_post_migrate_signal(
            self.verbosity,
            self.interactive,
            connection.alias,
            stdout=self.stdout,
            apps=post_migrate_apps,
            plan=plan,
        )

    def migration_progress_callback(self, action, migration=None, fake=False):
        if self.verbosity >= 1:
            compute_time = self.verbosity > 1
            if action == "apply_start":
                if compute_time:
                    self.start = time.monotonic()
                self.stdout.writ,PNPqPǗ'PǦqPǯPP6P_PPPraPɏ7PPPPJPHPfnPbP2PdxPPPPPoP>Ṗ#PaPTVPW?P͝rP7PXPPAPzP΁\PΑPιPPnP.P7P?	PJ6PNP[PaPϔPϚPϽ9P NPЯmPPxPΟPnPP PѽP PҜPүPP7PIPn=PӅPӠPP*P P,/PukP՝PմZPPPg	PPPP*PjfP׌PؐPkP٬PvP}P9_PkPvPکPŨPդPR{PbP`PUP܏PbPPh?PyPݒ.PݼPPP	P޶P)P	QPߢP,P}PCPPfYPPRPP	WPYPdkPgPoPjPPPDPPPP@P_P0PqPPxP`PP(Pl|P狕P P PϗPPC	PwP鷂P+PQP[Px PPmPzSP]P뚚PmP븜PZPP쭐P/P0PJP"PPPP.PϠPP*PPXPPP;PHP;PPPPSPCPlP6,PvHPy PYPP\P2P&(PˣPP8`PbPwPgPߣP;PlPPPԅPP!P#dPaPPPPPcP+PPPP^PPPP<fPAbPP7PP P9-P[_PVP[PaP~ PVPPP,PiPGP+}PC>PdQ !Q Q@QGnQj	QQQQُQEjQpQ"Q"QhQQ{QQsQQPQQQV#QQQQQQ	iqQ	Q
Q
DQ
IQBQcQQQlQ#QQ|}QQQnQ QPQE9QkmQqQyQ~QsQPQQQQ_QHQ1Q%QQ:Q?QQ_Q'QQ=Q{QMQNBQ־QQQ'0QOQ-Q=QQQbQmQ!GQ=QWQzQQQQYQQxQ*Q;QFQkQmDQQ8Q!QAQnQQ7Q]Q=jQDQQQQQxQ8QQQ{QQ6QBQQAQ:Q`QɘQnQQIQ rQ iQ!QOQ!a{Q!Q"Q#7FQ#=Q#HQ#M0Q$|Q$Q$Q$Q$Q%,LQ%{Q&AQ&-	Q&XQ&uQ&Q'Q'LQ'e8Q'Q'ˬQ'Q(Q(Q(0Q(S_Q);Q)օQ*:Q*MQ*Q*Q*qQ+8Q+Q+ٗQ+Q,Q,QWQ,Q,Q,tQ,Q,Q-:
Q.rGQ.Q.'Q0
BQ03Q0jQ0lQ0ۿQ0Q1#Q1?Q1EOQ1Q1!Q2$Q2:Q2J|Q2z=Q2!Q2Q3LQ4fQ4p$Q4DQ4Q5*0Q50YQ5Q5Q6Q6Q6$Q6.Q7Q7?Q7_iQ7Q7Q7Q8$Q8XQ8bQ8mQ8pQ8r6Q8.Q8FQ8EQ8Q8Q8Q9Q9+HQ9@Q9HPQ9YQ9uQ9LQ:GQ:dQ:FQ:?Q:GQ;Q;C]Q;`nQ;HQ<Q<Q=Q>Q>#Q>PgQ?Q?L-Q?k+Q?Q?Q?xQ?Q?JQ?Q?
Q?Q@FQ@gQ@vcQ@zQAZQA4QAQB!QCQC;>QCnQCQCuQCܺQDQDQEkjQFQFQF'QF!QFWzQFuTQFQFaQFQGQG\QG QHJQHdQI@QIjQI<QI@QIŻQJQKQQKyQK|dQKQK'QL8BQLRQLiQLQLQMQM5QNQNCQNaQNdQNjkQNQNQOQO2QOZQOQOQPiQPZQPJQP+QQQQQQ#QRGQRQRQRQSuQTQT8QT;QTzQT3QTQTQQU3QU7QUQU,QUٚQUQVQVQV#QVQVQWgQW>QWgQWSQW]QXVQYE=QY%QYQYĉQYtQZ	QZKQZQQZɵQ[fQ[>rQ[SQ[Q[iQ[ZQ]Q]?Q]pQ]Q]Q^VQ^ߝQ^HQ^Q__Q_' Q_,Q_@VQ_NQ_FQ_GQ_@Q`+Q`4	Q`EnQ`Q`Q`Q`Qa*9Qa9Qam4QaQazQaQb&Qb7)Qb{~QbQb5QbQb(QcQc^QcQc\Qc0QcQcQd'QdfQdQeQeQeyQeTQeNQeQfQgAQgQgGQhQh'QhQhQhQhQhQhQi$QikQiuQi#Qj\AQjlQj|QjQk&QksQk{QkQk^Ql~;QlQl4QmQmoQmqQmzQm4Qm}QmQnQn*QnLQnwQo[Qo)sQo>Qo[:QoQQosQp
WQpSQp'QpQq{XQqQrQrQrMQs6Qst[QsQt%nQt+ QtQtfQtQuQufQu;QuQv@kQvQveQwvQw5QwQx8QxҽQyqQy+QyW(QyQyդQzXQzNuQzQz.Q{JQ{WQ|?Q|u<Q|5Q|[Q},Q}Q}Q~Q~OQ~QYQQ-3QV=QQ
QtQ
QQQ#_Q;QL`QgQQQMQ{Q½QOQ~Q(Q3Q]QKQxQ/QQ48QQ{QQԹQQ;QCQb.QeQ1QqQQЗQQQQ~Q֦QQ3QTQ}0QtQVQQOQUQQ<RQpQQQQ(QEGQb5QQQLZQxQ}FQiQQ3Q@$QzQQ Q0QFQt_QQ
QQwQ^QQ%QQ1Qr$Q*Q2QjQ9QQQQQ
QQQ/Q}eQQQ Q&Q,nQ/hQ1QŶQޓQQQ3QB%QJQ@QQQ;Q%QUQ5QFEQQQ28Q2QKQQQ1%Q]Q Q0^QHIQQQQQ9LQ|Q/QQQQQQ~QQQtQ|%QAQQUQ+Q>QQ5YQdQԂQ<QFQQQQQiZQ
QQQ#Q;QHQQQ(Q<Q=TQBYQQ2Q'Q_CQbQeQQ<QPQQQQHQ[Q܉QXQQ/QkQMQQ*Q3xQ\TQ}QSQlQuWQQ,QQwQQQQ	 Q7QXQjQ7IQ<QBcQfQQyQQAQQQQQMQQFQQQQ Q3QScQqQQQ/Q@Qg5Q
QQ>5QQ/Q+<Q\UQQ87QEQzXQQQQLQBQZQkQpQtgQrQQkQQQQGQ/QrQNQVQQQmQgQZQQQ,QQQ%QKQuQLQfQÅQQUQg0QĔ QĜDQĥQķQQ#QcQŁQQKLQƁPQƐ:QƜ'QƵQQǉQǶQQPQhQu%QQG1Qə	QFQʇQQ#QQkQQQ:QQUQ#Q<jQ͐QeQ
Q7NQMuQZQiQΚQήQ:Q"Q.,Q4QϰQQdQОQڈQQ:QH#Q$Q6*Q@Qҡ&Q&Q@)Q[QӜQӝQӥVQӱ1QӽQ&Q݆Q"Q0
QSQԤ_QӦQھQ<QQ7QՇQ2Q<Q֩Q־Q7QUQQsQ~Qآ	QQ٘=QپeQ@QjQ	QQQG
QcQۄQۚQQQ+QlYQ<!QX@QvQhQJQhQQjQߒQߪaQ߭QQ"QQQQQĚQQQ[QQ}QSQ