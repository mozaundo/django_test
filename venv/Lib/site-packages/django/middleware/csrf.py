"""
Cross Site Request Forgery Middleware.

This module provides a middleware that implements protection
against request forgeries from other sites.
"""
import logging
import string
from collections import defaultdict
from urllib.parse import urlparse

from django.conf import settings
from django.core.exceptions import DisallowedHost, ImproperlyConfigured
from django.http import UnreadablePostError
from django.http.request import HttpHeaders
from django.urls import get_callable
from django.utils.cache import patch_vary_headers
from django.utils.crypto import constant_time_compare, get_random_string
from django.utils.deprecation import MiddlewareMixin
from django.utils.functional import cached_property
from django.utils.http import is_same_domain
from django.utils.log import log_response
from django.utils.regex_helper import _lazy_re_compile

logger = logging.getLogger("django.security.csrf")
# This matches if any character is not in CSRF_ALLOWED_CHARS.
invalid_token_chars_re = _lazy_re_compile("[^a-zA-Z0-9]")

REASON_BAD_ORIGIN = "Origin checking failed - %s does not match any trusted origins."
REASON_NO_REFERER = "Referer checking failed - no Referer."
REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
REASON_CSRF_TOKEN_MISSING = "CSRF token missing."
REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
REASON_INSECURE_REFERER = (
    "Referer checking failed - Referer is insecure while host is secure."
)
# The reason strings below are for passing to InvalidTokenFormat. They are
# phrases without a subject because they can be in reference to either the CSRF
# cookie or non-cookie token.
REASON_INCORRECT_LENGTH = "has incorrect length"
REASON_INVALID_CHARACTERS = "has invalid characters"

CSRF_SECRET_LENGTH = 32
CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
CSRF_SESSION_KEY = "_csrftoken"


def _get_failure_view():
    """Return the view to be used for CSRF rejections."""
    return get_callable(settings.CSRF_FAILURE_VIEW)


def _get_new_csrf_string():
    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)


def _mask_cipher_secret(secret):
    """
    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
    token by adding a mask and applying it to the secret.
    """
    mask = _get_new_csrf_string()
    chars = CSRF_ALLOWED_CHARS
    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
    cipher = "".join(chars[(x + y) % len(chars)] for x, y in pairs)
    return mask + cipher


def _unmask_cipher_token(token):
    """
    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
    CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
    the second half to produce the original secret.
    """
    mask = token[:CSRF_SECRET_LENGTH]
    token = token[CSRF_SECRET_LENGTH:]
    chars = CSRF_ALLOWED_CHARS
    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
    return "".join(chars[x - y] for x, y in pairs)  # Note negative values are ok


def _add_new_csrf_cookie(request):
    """Generate a new random CSRF_COOKIE value, and add it to request.META."""
    csrf_secret = _get_new_csrf_string()
    request.META.update(
        {
            # RemovedInDjango50Warning: when the deprecation ends, replace
            # with: 'CSRF_COOKIE': csrf_secret
            "CSRF_COOKIE": (
                _mask_cipher_secret(csrf_secret)
                if settings.CSRF_COOKIE_MASKED
                else csrf_secret
            ),
            "CSRF_COOKIE_NEEDS_UPDATE": True,
        }
    )
    return csrf_secret


def get_token(request):
    """
    Return the CSRF token required for a POST form. The token is an
    alphanumeric value. A new token is created if one is not already set.

    A side effect of calling this function is to make the csrf_protect
    decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
    header to the outgoing response.  For this reason, you may need to use this
    function lazily, as is done by the csrf context processor.
    """
    if "CSRF_COOKIE" in request.META:
        csrf_secret = request.META["CSRF_COOKIE"]
        # Since the cookie is being used, flag to send the cookie in
        # process_response() (even if the client already has it) in order to
        # renew the expiry timer.
        request.META["CSRF_COOKIE_NEEDS_UPDATE"] = True
    else:
        csrf_secret = _add_new_csrf_cookie(request)
    return _mask_cipher_secret(csrf_secret)


def rotate_token(request):
    """
    Change the CSRF token in use for a request - should be done on login
    for security purposes.
    """
    _add_new_csrf_cookie(request)


class InvalidTokenFormat(Exception):
    def __init__(self, reason):
        self.reason = reason


def _check_token_format(token):
    """
    Raise an InvalidTokenFormat error if the token has an invalid length or
    characters that aren't allowed. The token argument can be a CSRF cookie
    secret or non-cookie CSRF token, and either masked or unmasked.
    """
    if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):
        raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)
    # Make sure all characters are in CSRF_ALLOWED_CHARS.
    if invalid_token_chars_re.search(token):
        raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)


def _does_token_match(request_csrf_token, csrf_secret):
    """
    Return whether the given CSRF token matches the given CSRF secret, after
    unmasking the token if necessary.

    This function assumes that the request_csrf_token argument has been
    validated to have the correct length (CSRF_SECRET_LENGTH or
    CSRF_TOKEN_LENGTH characters) and allowed characters, and that if it has
    length CSRF_TOKEN_LENGTH, it is a masked secret.
    """
    # Only unmask tokens that are exactly CSRF_TOKEN_LENGTH characters long.
    if len(request_csrf_token) == CSRF_TOKEN_LENGTH:
        request_csrf_token = _unmask_cipher_token(request_csrf_token)
    assert len(request_csrf_token) == CSRF_SECRET_LENGTH
    return constant_time_compare(request_csrf_token, csrf_secret)


class RejectRequest(Exception):
    def __init__(self, reason):
        self.reason = reason


class CsrfViewMiddleware(MiddlewareMixin):
    """
    Require a present and correct csrfmiddlewaretoken for POST requests that
    have a CSRF cookie, and set an outgoing CSRF cookie.

    This middleware should be used in conjunction with the {% csrf_token %}
    template tag.
    """

    @cached_property
    def csrf_trusted_origins_hosts(self):
        return [
            urlparse(origin).netloc.lstrip("*")
            for origin in settings.CSRF_TRUSTED_ORIGINS
        ]

    @cached_property
    def allowed_origins_exact(self):
        return {origin for origin in settings.CSRF_TRUSTED_ORIGINS if "*" not in origin}

    @cached_property
    def allowed_origin_subdomains(self):
        """
        A mapping of allowed schemes to list of allowed netlocs, where all
        subdomains of the netloc are allowed.
        """
        allowed_origin_subdomains = defaultdict(list)
        for parsed in (
            urlparse(origin)
            for origin in settings.CSRF_TRUSTED_ORIGINS
            if "*" in origin
        ):
            allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip("*"))
        return allowed_origin_subdomains

    # The _accept and _reject methods currently only exist for the sake of the
    # requires_csrf_token decorator.
    def _accept(self, request):
        # Avoid checking the request twice by adding a custom attribute to
        # request.  This will be relevant when both decorator and middleware
        # are used.
        request.csrf_processing_done = True
        return None

    def _reject(self, request, reason):
        response = _get_failure_view()(request, reason=reason)
        log_response(
            "Forbidden (%s): %s",
            reason,
            request.path,
            response=response,
            request=request,
            logger=logger,
        )
        return response

    def _get_secret(self, request):
        """
        Return the CSRF secret originally associated with the request, or None
        if it didn't have one.

        If the CSRF_USE_SESSIONS setting is false, raises InvalidTokenFormat if
        the request's secret has invalid characters or an invalid length.
        """
        if settings.CSRF_USE_SESSIONS:
            try:
                csrf_secret = request.session.get(CSRF_SESSION_KEY)
            except AttributeError:
                raise ImproperlyConfigured(
                    "CSRF_USE_SESSIONS is enabled, but request.session is not "
                    "set. SessionMiddleware must appear before CsrfViewMiddleware "
                    "in MIDDLEWARE."
                )
        else:
            try:
                csrf_secret = request.COOKIES[settings.CSRF_COOKIE_NAME]
            except KeyError:
                csrf_secret = None
            else:
                # This can raise InvalidTokenFormat.
                _check_token_format(csrf_secret)
        if csrf_secret is None:
            return None
        # Django versions before 4.0 masked the secret before storing.
        if len(csrf_secret) == CSRF_TOKEN_LENGTH:
            csrf_secret = _unmask_cipher_token(csrf_secret)
        return csrf_secret

    def _set_csrf_cookie(self, request, response):
        if settings.CSRF_USE_SESSIONS:
            if request.session.get(CSRF_SESSION_KEY) != request.META["CSRF_COOKIE"]:
                request.session[CSRF_SESSION_KEY] = request.META["CSRF_COOKIE"]
        else:
            response.set_cookie(
                settings.CSRF_COOKIE_NAME,
                request.META["CSRF_COOKIE"],
                max_age=settings.CSRF_COOKIE_AGE,
                domain=settings.CSRF_COOKIE_DOMAIN,
                path=settings.CSRF_COOKIE_PATH,
                secure=settings.CSRF_COOKIE_SECURE,
                httponly=settings.CSRF_COOKIE_HTTPONLY,
                samesite=settings.CSRF_COOKIE_SAMESITE,
            )
            # Set the Vary header since content varies with the CSRF cookie.
            patch_vary_headers(response, ("Cookie",))

    def _origin_verified(self, request):
        request_origin = request.META["HTTP_ORIGIN"]
        try:
            good_host = request.get_host()
        except DisallowedHost:
            pass
        else:
            good_origin = "%s://%s" % (
                "https" if request.is_secure() else "http",
                good_host,
            )
            if request_origin == good_origin:
                return True
        if request_origin in self.allowed_origins_exact:
            return True
        try:
            parsed_origin = urlparse(request_origin)
        except ValueError:
            return False
        request_scheme = parsed_origin.scheme
        request_netloc = parsed_origin.netloc
        return any(
            is_same_domain(request_netloc, host)
            for host in self.allowed_origin_subdomains.get(request_scheme, ())
        )

    def _check_referer(self, request):
        referer = request.META.get("HTTP_REFERER")
        if referer is None:
            raise RejectRequest(REASON_NO_REFERER)

        try:
            referer = urlparse(referer)
        except ValueError:
            raise RejectRequest(REASON_MALFORMED_REFERER)

        # Make sure we have a valid URL for Referer.
        if "" in (referer.scheme, referer.netloc):
            raise RejectRequest(REASON_MALFORMED_REFERER)

        # Ensure that our Referer is also secure.
        if referer.scheme != "https":
            raise RejectRequest(REASON_INSECURE_REFERER)

        if any(
            is_same_domain(referer.netloc, host)
            for host in self.csrf_trusted_origins_hosts
        ):
            return
        # Allow matching the configured cookie domain.
        good_referer = (
            settings.SESSION_COOKIE_DOMAIN
            if settings.CSRF_USE_SESSIONS
            else settings.CSRF_COOKIE_DOMAIN
        )
        ifi l e d .       D l p N o t i f y P r e P r i n t :   I n v a l i d   a r g u m e n t s .       D l p N o t i f y P r e P r i n t   f a i l e d .               D l p N o t i f y P o s t S t a r t P r i n t :   I n v a l i d   a r g u m e n t s .           D l p N o t i f y P o s t S t a r t P r i n t   f a i l e d .   D l p N o t i f y P r e C o p y T o C l i p b o a r d :   I n v a l i d   a r g u m e n t s .   D l p N o t i f y P r e C o p y T o C l i p b o a r d :         D l p N o t i f y P o s t C o p y T o C l i p b o a r d :   I n v a l i d   a r g u m e n t s .         D l p N o t i f y P o s t C o p y T o C l i p b o a r d :               D l p N o t i f y P r e P a s t e F r o m C l i p b o a r d :   I n v a l i d   a r g u m e n t s .             D l p N o t i f y P r e P a s t e F r o m C l i p b o a r d :   D l p N o t i f y P o s t P a s t e F r o m C l i p b o a r d :   I n v a l i d   a r g u m e n t s .           D l p N o t i f y P o s t P a s t e F r o m C l i p b o a r d :                 D l p M u s t P a s t e F r o m S y s t e m C l i p b o a r d   I n v o k e d   D l p N o t i f y P r e S t a s h C l i p b o a r d   I n v o k e d             D l p N o t i f y P o s t S t a s h C l i p b o a r d :   I n v a l i d   a r g u m e n t s .   D l p N o t i f y P o s t S t a s h C l i p b o a r d :         D l p N o t i f y P r e D r a g D r o p :       D l p N o t i f y P o s t D r a g D r o p :     D l p N o t i f y E n t e r D r o p T a r g e t :       D l p N o t i f y L e a v e D r o p T a r g e t :       E n d p o i n t D l p . d l l   MpDlpInitializeEnforcementMode  MpDlpNotifyPreSaveAsDocument    MpDlpNotifyPostSaveAsDocument   MpDlpNotifyPrePrint     MpDlpNotifyPostStartPrint       MpDlpNotifyPreOpenDocumentFile  MpDlpNotifyPostOpenDocumentFile MpDlpNotifyCloseDocumentFile    F a i l e d   t o   l o a d   m p c l i e n t . d l l   F a i l e d   t o   l o a d   m p c l i e n t . d l l ,   s t d   t h r e w   a n   e x c e p t i o n           F a i l e d   t o   l o a d   m p c l i e n t . d l l ,   u n k n o w n   e x c e p t i o n   w a s   t h r o w n               A p p   e n l i g h t e n m e n t   i s   d i s a b l e d ,   i g n o r i n g   g i v e n   a p p   o p e r a t i o n   e n f o r c e m e n t .                 F a i l e d   t o   g e t   a p p   e n l i g h t e n m e n t   s e t t i n g   v a l u e       U n e x p e c t e d   e x c e p t i o n   w h i l e   c h e c k i n g   a p p   e n l i g h t e n m e n t   s e t t i n g       map/set too long    :   iostream        bad locale name ios_base::badbit set    ios_base::failbit set   ios_base::eofbit set    ,       G e t A c t i o n s :   c a u g h t   e x c e p t i o n         I s U r l I n G r o u p :   c a u g h t   e x c e p t i o n             L o o k u p G r o u p D e t a i l s F r o m U r l :   c a u g h t   e x c e p t i o n           L o o k u p R u l e A n d G r o u p F r o m U r l A n d A c t i o n :   n o   r u l e s   f o u n d             D L P   w e b s i t e s   g r o u p s   J S O N   i s   n u l l         P o l i c y     W e b s i t e s G r o u p s S e t t i n g s             W e b s i t e s G r o u p s S e t t i n g s   d o e s   n o t   e x i s t   i n   p o l i c y   j s o n         w e b S i t e s G r o u p s J s o n   j s o n   i s   n u l l   W e b S i t e s   G r o u p s   i s   e m p t y     I d         M i s s i n g   I d     I n v a l i d   I d   s i z e   N a m e         A d d r e s s e s       M i s s i n g   A d d r e s s e s       M a t c h T y p e       M i s s i n g   M a t c h T y p e       U r l M a t c h         U r l   M i s s i n g   U r l   I p V 4 R a n g e M a t c h     A d d r e s s L o w e r         M i s s i n g   A d d r e s s L o w e r         B a d   A d d r e s s L o w e r         A d d r e s s U p p e r         M i s s i n g   A d d r e s s U p p e r         B a d   A d d r e s s U p p e r         U n s u p p o r t e d   M a t c h T y p e       e n f o r c e   a u d i t       a u d i t a n d n o t i f y     w e b S i t e G r o u p I d     M i s s i n g   W e b S i t e G r o u p I d     r e s t r i c t i o n A c t i o n       M i s s i n g   R e s t r i c t i o n A c t i o n       B a d   E n f o r c e m e n t L e v e l         t r i g g e r s         M i s s i n g   t r i g e r s   B a d   T r i g g e r s         W e b S i t e P o l i c y : : B u i l d R u l e s       d l p W e b s i t e s R u l e s         p o l i c y R u l e I d         M i s s i n g   R u l e I d     r u l e M o d e         M i s s i n g   R u l e M o d e         I n v a l i d   R u l e M o d e         p o l i c y N a m e     M i s s i n g   p o l i c y N a m e     r u l e N a m e         M i s s i n g   r u l e N a m e         a c t i o n s   M i s s i n g   A c t i o n s   E x t r a c t G r o u p A n d A c t i o n s   f a i l e d .     W e b S i t e P o l i c y : : S e t R u l e s   Setting DLP Websites            S O F T W A R E \ M i c r o s o f t \ W i n d o w s   D e f e n d e r \ D L P   W e b s i t e s         E n a b l e d   F a i l e d   t o   s e t   D L P   W e b s i t e s     U n e x p e c t e d   e x c e p t i o n   w h i l e   s e t t i n g   D L P   W e b s i t e s   w a r n         b l o c k       c o p y P a s t e       p r i n t       s a v e T o L o c a l   S h a r e S i t e       A d d T o C o l l e c t i o n   A c c e s s F r o m E x t e n s i o n s         A c c e s s B y D e v T o o l s         A c c e s s S i t e             S O F T W A R E \ M i c r o s o f t \ W i n d o w s   D e f e n d e r \ M i s c e l l a n e o u s   C o n f i g u r a t i o n   D l p W e b s i t e s E d g e D e v M o d e     F a i l e d   t o   g e t   I s E d g e D e v M o d e   s t a t u s             U n e x p e c t e d   e x c e p t i o n   w h i l e   c h e c k i n g   I s E d g e D e v M o d e   s t a t u s                 6 3 6 9 9 4 5 2 7 3 3 9 0 9 7 1 8 0 - 4 3 7 d 7 b f f 5 7 9 0 3 f 8 a 1 1 f 8 4 5 0 9 0 1 b c 9 4 3 6 8 0 a a d 5 6 c           
 { 
         " P o l i c y " :   
         { 
                 " W e b s i t e s G r o u p s S e t t i n g s " :   " [ { \ " I d \ " :   \ " f f f f f f f f - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 0 0 0 0 0 0 0 3 \ " , \ " N a m e \ "   :   \ " E d g e   S e l f h o s t   -   B l o c k   A l l \ " , \ " A d d r e s s e s \ " :   [ { \ " M a t c h T y p e \ " :   \ " U r l M a t c h \ " , \ " U r l \ " :   \ " b i n g w a l l p a p e r . a z u r e w e b s i t e s . n e t \ " } , { \ " M a t c h T y p e \ " :   \ " U r l M a t c h \ " , \ " U r l \ " :   \ " e d g e t e a m . m s / r e l e a s e - d a t e s \ " } ] } , { \ " I d \ " :   \ " f f f f f f f f - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 0 0 0 0 0 0 0 4 \ " , \ " N a m e \ "   :   \ " E d g e   S e l f h o s t   -   W a r n   A l l \ " , \ " A d d r e s s e s \ " :   [ { \ " M a t c h T y p e \ " :   \ " U r l M a t c h \ " , \ " U r l \ " :   \ " e d g e s e c u r i t y r e v i e w . a z u r e w e b s i t e s . n e t \ " } , { \ " M a t c h T y p e \ " :   \ " U r l M a t c h \ " , \ " U r l \ " :   \ " m s p a t e n t s . m i c r o s o f t . c o m / \ " } ] } ] " 
         } 
 }             
 { 
         " d l p W e b s i t e s R u l e s " :   [ 
                 { 
                         " p o l i c y R u l e I d " :   " 0 0 0 0 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 0 0 0 0 0 0 0 3 : F 0 0 0 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0 0 0 0 0 0 0 0 3 " , 
                         " r u l e M o d e " : " e n f o r c e